// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: _.proto
/* eslint-disable */

import * as _P from "@3-/protoscript";

const EMPTY_BIN = new Uint8Array();

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const STATE_OK = 0;
export const STATE_JSON = 1;
export const STATE_CODE = 2;
export const STATE_CODE_LI = 3;
export const STATE_BIN = 4;
export const STATE_CAPTCHA = 10;
export const STATE_NEED_SIGNIN = 11;
export const STATE_NO_PERMISSION = 12;
export const STATE_MISS_FUNC = 100;
export const STATE_ARGS_INVALID = 101;
export const STATE_BATCH_LIMIT = 102;
export const STATE_CALL_ERROR = 103;
export const STATE_MIDDLEWARE_ERROR = 104;

/**
 * Serializes CallLi to protobuf.
 */
export const CallLiEncode = (msg) =>
  _P.getResultBuffer(CallLiWrite(msg, _P.binaryWriter()));
/**
 * Deserializes CallLi from protobuf.
 */
export const CallLiDecode = (bytes) =>
  CallLiRead(CallLiNew(), _P.binaryReader(bytes));
const CallLiNew = () => [[], []];
const CallLiWrite = _P.encoder(_P.writePackedUint32, _P.writeRepeatedBytes);
const CallLiRead = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        if (_P.isDelimited(reader)) {
          msg[0].push(..._P.readPackedUint32(reader));
        } else {
          msg[0].push(_P.readUint32(reader));
        }
        break;
      }
      case 2: {
        msg[1].push(_P.readBytes(reader));
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes BinLi to protobuf.
 */
export const BinLiEncode = (msg) =>
  _P.getResultBuffer(BinLiWrite(msg, _P.binaryWriter()));
/**
 * Deserializes BinLi from protobuf.
 */
export const BinLiDecode = (bytes) =>
  BinLiRead(BinLiNew(), _P.binaryReader(bytes));
const BinLiNew = () => [[], []];
const BinLiWrite = _P.encoder(_P.writePackedUint32, _P.writeRepeatedBytes);
const BinLiRead = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        if (_P.isDelimited(reader)) {
          msg[0].push(..._P.readPackedUint32(reader));
        } else {
          msg[0].push(_P.readUint32(reader));
        }
        break;
      }
      case 2: {
        msg[1].push(_P.readBytes(reader));
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes Code to protobuf.
 */
export const CodeEncode = (msg) =>
  _P.getResultBuffer(CodeWrite(msg, _P.binaryWriter()));
/**
 * Deserializes Code from protobuf.
 */
export const CodeDecode = (bytes) =>
  CodeRead(CodeNew(), _P.binaryReader(bytes));
const CodeNew = () => 0;
const CodeWrite = _P.encoder1(_P.writeUint32);
const CodeRead = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        msg = _P.readUint32(reader);
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes CodeLi to protobuf.
 */
export const CodeLiEncode = (msg) =>
  _P.getResultBuffer(CodeLiWrite(msg, _P.binaryWriter()));
/**
 * Deserializes CodeLi from protobuf.
 */
export const CodeLiDecode = (bytes) =>
  CodeLiRead(CodeLiNew(), _P.binaryReader(bytes));
const CodeLiNew = () => [];
const CodeLiWrite = _P.encoder1(_P.writePackedUint32);
const CodeLiRead = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        if (_P.isDelimited(reader)) {
          msg.push(..._P.readPackedUint32(reader));
        } else {
          msg.push(_P.readUint32(reader));
        }
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes Json to protobuf.
 */
export const JsonEncode = (msg) =>
  _P.getResultBuffer(JsonWrite(msg, _P.binaryWriter()));
/**
 * Deserializes Json from protobuf.
 */
export const JsonDecode = (bytes) =>
  JsonRead(JsonNew(), _P.binaryReader(bytes));
const JsonNew = () => "";
const JsonWrite = _P.encoder1(_P.writeString);
const JsonRead = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        msg = _P.readString(reader);
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes Bin to protobuf.
 */
export const BinEncode = (msg) =>
  _P.getResultBuffer(BinWrite(msg, _P.binaryWriter()));
/**
 * Deserializes Bin from protobuf.
 */
export const BinDecode = (bytes) => BinRead(BinNew(), _P.binaryReader(bytes));
const BinNew = () => EMPTY_BIN;
const BinWrite = _P.encoder1(_P.writeBytes);
const BinRead = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        msg = _P.readBytes(reader);
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes Captcha to protobuf.
 */
export const CaptchaEncode = (msg) =>
  _P.getResultBuffer(CaptchaWrite(msg, _P.binaryWriter()));
/**
 * Deserializes Captcha from protobuf.
 */
export const CaptchaDecode = (bytes) =>
  CaptchaRead(CaptchaNew(), _P.binaryReader(bytes));
const CaptchaNew = () => [EMPTY_BIN, EMPTY_BIN, EMPTY_BIN];
const CaptchaWrite = _P.encoder(_P.writeBytes, _P.writeBytes, _P.writeBytes);
const CaptchaRead = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        msg[0] = _P.readBytes(reader);
        break;
      }
      case 2: {
        msg[1] = _P.readBytes(reader);
        break;
      }
      case 3: {
        msg[2] = _P.readBytes(reader);
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
